#+title: C语言速查笔记
#+date: <2025-04-19 六>
#+description:  抄别人blog的东西，塞一起应该方便自己查吧？

#+setupfile: ../../../setup.setup

* 前言
这玩意还是我自己吃菌子吃多了头脑发热写的东西，不过他应该不会像隔壁“某教程”那样
写着写着就弃坑变成了烂尾楼

当然，真正的理由还是翻自己的收藏夹发现收藏了一堆网页，但一大堆都是CSDN的shit，想
着能不能把他们从收藏夹里面“优化”掉，所以就想抄到自己这里来hhh

以下内容或许可以参考[[https://gitee.com/YouLanjie/my-test][这个仓库]]的C语言部分，我有些实例代码是写在里面的

* 使用ANSI转义字符为打印的字符上色
特殊效果的支持源自ANSI标准，由于我不是很懂所以不多赘述。这里重点关注我们应该如何使用它。

先说结论：\\
要使用特殊效果，通常需要使用任意输出函数输出以 =\033[数字选项+字符选项= 为格式的字符串。

其中，字符选项相当于指定了其大概的类型，只可以单独使用，并作为一串控制字符串的结
束。而数字选项则是细分了其具体功能，且可以复用，只需要使用分号将其隔开。

例子请续看下文。
** 颜色
#+BEGIN_QUOTE
做出一些提醒，该子标题内的内容都需要一个关键的字符 =m= ，所有的文字效果都是基于
=\033[XXm= 的格式，只是为了方便理解，在大部分内容都不作为重点讲述。
#+END_QUOTE
*** 使用普通颜色（非256色）
要打印出普通的颜色，只需要使用下面的程序：
#+BEGIN_SRC C
  #include <stdio.h>

  int main()
  {
          int color_code = 31;    /* 这里使用变量不是必须的，只是为了更容易看懂，实际上需要打印出对应的数字即可 */
          printf("\033[%dm"
                 "在这里放你想要带特殊效果打印的东西\n",
                 color_code);
          return 0;
  }
#+END_SRC
下面是所有关于颜色控制的数字表格，左侧是字体颜色，右侧是背景颜色。
| 数字 | 字体颜色  | 数字 | 背景颜色  |
|------+-----------+------+-----------|
|   30 | 黑色      |   40 | 默认/无色 |
|   31 | 红色      |   41 | 红色      |
|   32 | 绿色      |   42 | 绿色      |
|   33 | 黄色/橙色 |   43 | 黄色/橙色 |
|   34 | 蓝色      |   44 | 蓝色      |
|   35 | 紫色      |   45 | 紫色      |
|   36 | 青色      |   46 | 青色      |
|   37 | 白色      |   47 | 白色      |

#+BEGIN_QUOTE
顺带一提，这些控制代码是“可堆叠的”，意思就是不通的颜色代码可以使用分号 =;= 隔断开来，这样就不必打上好几个 =\033[...= 让代码变得难以阅读。这里再举一个例子做示范。
#+BEGIN_SRC C
  #include <stdio.h>
  int main()
  {
          int color_code_bg = 44,    /* 蓝色背景 */
              color_code_fg = 31;    /* 红色字体 */
          /* 这里的转义相当于 \033[44;31m */
          printf("\033[%d;%dm"
                 "Put someting here you want to print.\n",
                 color_code_bg, color_code_fg);
          return 0;
  }
#+END_SRC
#+END_QUOTE
*** 使用真彩色（256色）
在这种情况下，我们可以打印出256种颜色，比普通颜色高级多了。不过我也还是不知道Vim
和Emacs这些编辑器使用主题时是怎样打印任意颜色的。毕竟我取过色，发现我使用的主题
有很多都不在256色的范围内，所以说挺令我困惑的。

废话少说，先上代码示范。

#+BEGIN_SRC C
  #include <stdio.h>

  int main()
  {
          int color_code = 0;
          /* 在这里将各段控制字符分开是为了方便理解，不是必须的 */
          for (color_code = 0; color_code < 256; color_code++) {
                  if (color_code >= 16 && (color_code - 16) % 6 == 0) {
                          printf("\n");
                  }
                  printf("\033["
                         "48;"
                         "5;"
                         "%dm"
                         "%03d"
                         "\033[0m ",
                         color_code, color_code);
          }
          printf("\n");
          return 0;
  }
#+END_SRC
下面开始讲解。

要想使用256色的输出，你需要的是 =48;5;%dm= 这样一串控制符。
其中的 =48;5;= 就是关键。

在这里 =48= 的意思实际上应该是告诉颜色的类型是背景颜色，如果想要设置字体的颜色，
只需要将其替换成 =38= 即可。

接下来的 =5= 我就不清楚具体的作用了。我只提上一点：如果单独使用它，那么它所对应
的效果实际上是 *字体闪烁* 。

** 文字效果
如果你观察仔细，就应该会发现刚刚的代码里面有一些新的控制符，例如刚刚提到的 =\033[5m;= 也有 =\033[0m= 。现在，是时候列出一个效果列表了。
| 控制符 | 效果                                 |
|--------+--------------------------------------|
|      0 | 清除所有文字效果                     |
|      1 | 加粗文字                             |
|      2 | 细化文字                             |
|      3 | 斜体                                 |
|      4 | 下划线                               |
|      5 | 闪烁                                 |
|      6 | 未知                                 |
|      7 | 颜色反转（字体和背景颜色互换）       |
|      8 | 隐藏字体（或许可以尝试做一些彩蛋？） |

** 其他类型
*** 光标移动
| 空字符 | 效果 |
|--------+------|
| D      | 左   |
| C      | 右   |
| A      | 上   |
| B      | 下   |
这种情况下，数字参数用于指定步数
*** 光标显示
隐藏光标： =\033[?25l=

显示光标： =\033[?25h=
*** 光标位置
保存： =\033[u=

还原： =\033[l=
* Linux Signal信号
[[https://www.cnblogs.com/frisk/p/11602973.html][来源]]
#+begin_src c
  SIGHUP       1          /* Hangup (POSIX).  */                          终止进程     终端线路挂断
  SIGINT       2       /* Interrupt (ANSI).  */                        终止进程     中断进程 Ctrl+C
  SIGQUIT      3          /* Quit (POSIX).  */                            建立CORE文件终止进程，并且生成core文件 Ctrl+\
  SIGILL       4          /* Illegal instruction (ANSI).  */              建立CORE文件,非法指令
  SIGTRAP      5          /* Trace trap (POSIX).  */                      建立CORE文件,跟踪自陷
  SIGABRT      6          /* Abort (ANSI).  */
  SIGIOT       6          /* IOT trap (4.2 BSD).  */                      建立CORE文件,执行I/O自陷
  SIGBUS       7          /* BUS error (4.2 BSD).  */                     建立CORE文件,总线错误
  SIGFPE       8          /* Floating-point exception (ANSI).  */         建立CORE文件,浮点异常
  SIGKILL      9        /* Kill, unblockable (POSIX).  */               终止进程     杀死进程
  SIGUSR1      10         /* User-defined signal 1 (POSIX).  */           终止进程     用户定义信号1
  SIGSEGV      11         /* Segmentation violation (ANSI).  */           建立CORE文件,段非法错误
  SIGUSR2      12         /* User-defined signal 2 (POSIX).  */           终止进程     用户定义信号2
  SIGPIPE      13         /* Broken pipe (POSIX).  */                     终止进程     向一个没有读进程的管道写数据
  SIGALARM     14       /* Alarm clock (POSIX).  */                     终止进程     计时器到时
  SIGTERM      15       /* Termination (ANSI).  */                      终止进程     软件终止信号
  SIGSTKFLT    16         /* Stack fault.  */
  SIGCLD       SIGCHLD    /* Same as SIGCHLD (System V).  */
  SIGCHLD      17         /* Child status has changed (POSIX).  */        忽略信号     当子进程停止或退出时通知父进程
  SIGCONT      18         /* Continue (POSIX).  */                        忽略信号     继续执行一个停止的进程
  SIGSTOP      19         /* Stop, unblockable (POSIX).  */               停止进程     非终端来的停止信号
  SIGTSTP      20         /* Keyboard stop (POSIX).  */                   停止进程     终端来的停止信号 Ctrl+Z
  SIGTTIN      21         /* Background read from tty (POSIX).  */        停止进程     后台进程读终端
  SIGTTOU      22         /* Background write to tty (POSIX).  */         停止进程     后台进程写终端
  SIGURG       23         /* Urgent condition on socket (4.2 BSD).  */    忽略信号     I/O紧急信号
  SIGXCPU      24         /* CPU limit exceeded (4.2 BSD).  */            终止进程     CPU时限超时
  SIGXFSZ      25         /* File size limit exceeded (4.2 BSD).  */      终止进程     文件长度过长
  SIGVTALRM    26         /* Virtual alarm clock (4.2 BSD).  */           终止进程     虚拟计时器到时
  SIGPROF      27         /* Profiling alarm clock (4.2 BSD).  */         终止进程     统计分布图用计时器到时
  SIGWINCH     28         /* Window size change (4.3 BSD, Sun).  */       忽略信号     窗口大小发生变化
  SIGPOLL      SIGIO      /* Pollable event occurred (System V).  */
  SIGIO        29         /* I/O now possible (4.2 BSD).  */              忽略信号     描述符上可以进行I/O
  SIGPWR       30         /* Power failure restart (System V).  */
  SIGSYS       31         /* Bad system call.  */
  SIGUNUSED    31
#+end_src

* RELRO等安全选项
[[https://blog.csdn.net/tabactivity/article/details/126660974][来源]]
编译时使用 =-z now= 选项

* 判断字符是中文还是英文(有局限)
[[https://blog.csdn.net/shen_chengfeng/article/details/109161829][来源]]
#+begin_src c
  #include <stdio.h>
  #include <string.h>
   
  int main(int argc, char** argv)
  {
  	if(argc != 2) {
  		printf("Usage:\n./xxx str\n");
  		return 0;
  	}
  	
  	char *p = argv[1];
  	int   len = strlen(p);
  	for(int i = 0; i < len; i++) {
  		if( *p & 0x80) {
  			printf("chinese: %x\n", *p);
  		} else {
  			printf("english: %x\n", *p);
  		}
  		p++;
  	}
  	return 0;
  }
#+end_src
（以上代码可在my-test中找到）

* 生成迷宫
[[https://blog.csdn.net/jjwwwww/article/details/82872922][来源]] - 该程序与下列代码有较大出入
#+begin_src c
  #include <stdio.h>
  #include <stdlib.h>
  #include <unistd.h>
  #include <time.h>

  #define SECOND 1000000
  #define TPS    (SECOND / 20)

  //地图长度L，包括迷宫主体20，外侧的包围的墙体2，
  //最外侧包围路径2（之后会解释）
  #define L (20 + 4)

  //墙和路径的标识
  #define WALL  0
  #define ROUTE 1
  #define MARK  2
  #define WALL_C  "国"
  #define ROUTE_C "  "
  #define MARK_C  ":;"

  int **Maze = NULL;
  static int Rank = 0; // 控制迷宫的复杂度，数值越大复杂度越低，最小值为0
  int level = 0;

  void init();
  void print_map();
  void CreateMaze(int **maze, int x, int y); //生成迷宫

  int main(void)
  {				/*{{{ */
  	printf("\033[?25l");
  	init();
  	print_map();

  	//创造迷宫，（2，2）为起点
  	CreateMaze(Maze, 2, 2);

  	//画迷宫的入口和出口
  	Maze[2][1] = ROUTE;

  	//由于算法随机性，出口有一定概率不在（L-3,L-2）处，
  	//此时需要寻找出口
  	for (int i = L - 3; i >= 0; i--) {
  		if (Maze[i][L - 3] == ROUTE) {
  			Maze[i][L - 2] = ROUTE;
  			break;
  		}
  	}

  	print_map();
  	printf("\033[%dB", L);

  	FILE *fp = fopen("maze.txt", "w");
  	if (!fp) goto LEAVE;
  	for (int i = 1; i < L - 1; i++) {
  		for (int j = 1; j < L - 1; j++) {
  			fprintf(fp, "%d ", Maze[i][j]);
  		}
  		fprintf(fp, "\n");
  	}
  	fclose(fp);

  LEAVE:
  	printf("\033[?25h");
  	for (int i = 0; i < L; i++)
  		free(Maze[i]);
  	free(Maze);
  	return 0;
  }				/*}}} */

  void init()
  {				/*{{{ */
  	srand((unsigned)time(NULL));

  	Maze = (int **)malloc(L * sizeof(int *));
  	for (int i = 0; i < L; i++) {
  		Maze[i] = (int *)calloc(L, sizeof(int));
  	}

  	// 最外围层设为路径的原因，为了防止挖路时挖出边界，
  	// 同时为了保护迷宫主体外的一圈墙体被挖穿
  	for (int i = 0; i < L; i++) {
  		Maze[i][0] = ROUTE;
  		Maze[0][i] = ROUTE;
  		Maze[i][L - 1] = ROUTE;
  		Maze[L - 1][i] = ROUTE;
  	}
  	return;
  }				/*}}} */

  void print_map()
  {				/*{{{ */
  	int l = L - 2;
  	int deep = L * L / 2 - Rank;    /* 并无实际意义，经验公式 */

  	//画迷宫
  	for (int i = 1; i < L - 1; i++) {
  		for (int j = 1; j < L - 1; j++) {
  			printf("%s",
  			       Maze[i][j] != WALL ? (Maze[i][j] == MARK ? MARK_C : ROUTE_C ) : WALL_C);
  		}
  		printf("\n");
  	}
  	printf("\033[%dA", l);
  	printf("\033[%dC  | 符号解释: '%s'为遍历节点\n", l*2, MARK_C);
  	printf("\033[%dC  |           '%s'为走道\n", l*2, ROUTE_C);
  	printf("\033[%dC  |           '%s'为边墙\n", l*2, WALL_C);
  	printf("\033[%dC  | 全图边长: %d\n", l*2, L);
  	printf("\033[%dC  | 实体边长: %d\n", l*2, l);
  	printf("\033[%dC  | 本体边长: %d\n", l*2, l - 2);
  	printf("\033[%dC  | 复杂程度: %d (值越小越复杂) \n", l*2, Rank);
  	printf("\033[%dC  | 延迟时间: %.4fs\n", l*2, (double)(int)TPS/SECOND);
  	printf("\033[%dC  | 遍历深度: %-3d [%4.1f%%]\n", l*2, level, (double)level / deep * 100);
  	printf("\033[1A\033[%dC [", l*2 + 25);
  	int lim = 80 - (l*2 + 28);
  	for (int i = 0; i < lim; i++) {
  		printf((double)i / lim < (double)level / deep ? "#" : " ");
  	}
  	printf("]\n");
  	printf("\033[%dA", 9);
  	return;
  }				/*}}} */

  void CreateMaze(int **maze, int x, int y)
  {				/*{{{ */
  	level++;
  	maze[x][y] = maze[x][y] == WALL ? ROUTE : maze[x][y];

  	//确保四个方向随机
  	int direction[4][2] = { {1, 0}, {-1, 0}, {0, 1}, {0, -1} };
  	for (int i = 0; i < 4; i++) {
  		/* Swap data */
  		int r = rand() % 4;
  		int temp = direction[0][0];
  		direction[0][0] = direction[r][0];
  		direction[r][0] = temp;

  		temp = direction[0][1];
  		direction[0][1] = direction[r][1];
  		direction[r][1] = temp;
  	}

  	//向四个方向开挖
  	for (int i = 0; i < 4; i++) {
  		int dx = x;
  		int dy = y;

  		//控制挖的距离，由Rank来调整大小
  		int range = 1 + (Rank == 0 ? 0 : rand() % Rank);
  		while (range > 0) {
  			dx += direction[i][0];
  			dy += direction[i][1];

  			//排除掉回头路
  			if (maze[dx][dy] != WALL) {
  				break;
  			}
  			//判断是否挖穿路径
  			int count = 0;
  			for (int j = dx - 1; j < dx + 2; j++) {
  				for (int k = dy - 1; k < dy + 2; k++) {
  					// abs(j - dx) + abs(k - dy) == 1 
  					// 确保只判断九宫格的四个特定位置
  					if (abs(j - dx) + abs(k - dy) == 1
  					    && maze[j][k] != WALL) {
  						count++;
  					}
  				}
  			}

  			if (count > 1) {
  				break;
  			}
  			//确保不会挖穿时，前进
  			--range;
  			maze[dx][dy] = ROUTE;
  			print_map();
  			usleep(TPS);
  		}

  		//没有挖穿危险，以此为节点递归
  		if (range <= 0) {
  			maze[dx][dy] = MARK;
  			CreateMaze(maze, dx, dy);
  			maze[dx][dy] = ROUTE;
  		}
  	}
  	level--;
  	return;
  }				/*}}} */

#+end_src
（以上代码可在my-test中找到）
